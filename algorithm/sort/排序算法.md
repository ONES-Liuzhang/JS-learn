## 排序算法

1. 冒泡排序 bubbleSort

是稳定排序：冒泡排序每次交换才会改变顺序，对于两个相等的值不进行交换，就能保证相同大小的元素顺序不会发生变化
是原地排序，不会声明额外的空间

- 时间复杂度 O(n2)
- 空间复杂度 O(1)

2. 插入排序 insertSort

有序部分 + 无序部分

每次循环拿无序部分的第一个数，在有序部分中找到合适的位置插入进去

是稳定排序，原地排序

- 时间复杂度 O(n2)
- 空间复杂度 O(1)

3. 选择排序 selectSort

有序部分 + 无序部分

每次循环从无序部分选择最小值 min 和 无序部分第一个值进行交换

不是稳定排序，是原地排序

- 时间复杂度 O(n2)
- 空间复杂度 O(1)

4. 归并排序 mergeSort

是稳定排序：当合并两个数组时，遇到两个数组内相同元素大小时，先把前半部分的值放入零时数组，再放后半部分的，这样就可以保证其稳定性
不是原地排序，会耗费额外的空间

- 时间复杂度 O(nlogn)
- 空间复杂度 O(n + logn)
  - n 每次递归都会创建一个临时数组 temp 来储存合并后的数组
  - logn 每次递归都会声明常量空间

5. 快速排序 quickSort

不是稳定排序，是原地排序

- 时间复杂度 O(nlogn)
- 空间复杂度 O(logn) 最差情况可能是 O(n2)

6. 桶排序 bucketSort

先将数据按照分为 m 个部分，分别对每个部分使用快速排序进行排序，最终再把这个 m 个部分合起来（直接合起来就要有序，不能再排序）。

对数据有特殊要求，数据的范围不能太大，比如按照年龄对 100 万条数据进行排序，年龄的范围可以在 0-150 之间，把数据分为 150 个桶，第 i 个桶来储存年龄为 i 的所有数据

首先遍历这 100 万条数据，按照年龄放入

- 时间复杂度 O(n)

7. 计数排序 countingSort
